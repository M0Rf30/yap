// Package files provides unified file system operations for package building.
package files

import (
	"debug/elf"
	"io"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/pkg/errors"

	"github.com/M0Rf30/yap/v2/pkg/i18n"
	"github.com/M0Rf30/yap/v2/pkg/logger"
)

// Buffer pool for file operations to reduce memory allocations
var bufferPool = sync.Pool{
	New: func() interface{} {
		return make([]byte, 32*1024) // 32KB buffer
	},
}

// CheckWritable checks if a file is writable.
func CheckWritable(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_stat_file"))
	}

	if info.Mode().Perm()&0o200 == 0 {
		return errors.Errorf(i18n.T("errors.files.file_not_writable"), path)
	}

	return nil
}

// Chmod changes file permissions.
func Chmod(path string, perm os.FileMode) error {
	if err := os.Chmod(path, perm); err != nil {
		logger.Error(i18n.T("logger.chmod.error.failed_to_chmod_1"), "path", path, "error", err)
		return errors.Wrap(err, i18n.T("errors.files.failed_to_change_permissions"))
	}

	return nil
}

// Create creates a new file.
func Create(path string) (*os.File, error) {
	cleanFilePath := filepath.Clean(path)

	file, err := os.Create(cleanFilePath)
	if err != nil {
		logger.Error(i18n.T("logger.create.error.failed_to_create_path_1"), "path", path, "error", err)
		return nil, err
	}

	return file, nil
}

// CreateWrite creates a file and writes data to it.
func CreateWrite(path, data string) error {
	file, err := Create(path)
	if err != nil {
		return err
	}

	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			logger.Warn(i18n.T("logger.files.warn.close_write"), "path", path, "error", closeErr)
		}
	}()

	if _, err = file.WriteString(data); err != nil {
		logger.Error(i18n.T("logger.createwrite.error.failed_to_write_to_1"), "path", path, "error", err)
		return err
	}

	return nil
}

// Exists checks if a file or directory exists.
func Exists(path string) bool {
	_, err := os.Stat(path)
	return err == nil || !os.IsNotExist(err)
}

// ExistsMakeDir creates a directory if it doesn't exist.
func ExistsMakeDir(path string) error {
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		if err := os.MkdirAll(path, 0o750); err != nil {
			return errors.Errorf(i18n.T("errors.files.failed_to_create_directory"), path)
		}
	} else if err != nil {
		return errors.Errorf(i18n.T("errors.files.failed_to_access_directory"), path)
	}

	return nil
}

// Open opens a file for reading.
func Open(path string) (*os.File, error) {
	cleanFilePath := filepath.Clean(path)

	file, err := os.Open(cleanFilePath)
	if err != nil {
		logger.Error(i18n.T("logger.open.error.failed_to_open_file_1"), "path", path, "error", err)
		return nil, err
	}

	return file, nil
}

// TryHardLink attempts to create a hard link instead of copying a file.
// Falls back to regular file copy if hard linking fails.
func TryHardLink(src, dst string) error {
	// Try to create a hard link first
	if err := os.Link(src, dst); err == nil {
		return nil
	}

	// Fall back to copying the file
	srcFile, err := os.Open(src) // #nosec G304 - src path is controlled by caller
	if err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_open_source_file"))
	}

	defer func() { _ = srcFile.Close() }()

	dstFile, err := os.Create(dst) // #nosec G304 - dst path is controlled by caller
	if err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_create_destination_file"))
	}

	defer func() { _ = dstFile.Close() }()

	// Use buffer from pool for better performance
	buffer := bufferPool.Get().([]byte)
	defer bufferPool.Put(&buffer)

	if _, err := io.CopyBuffer(dstFile, srcFile, buffer); err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_copy_file_content"))
	}

	// Copy file permissions
	if srcInfo, err := srcFile.Stat(); err == nil {
		if err := os.Chmod(dst, srcInfo.Mode()); err != nil {
			logger.Warn(i18n.T("logger.tryhardlink.warn.failed_to_copy_file_1"), "dst", dst, "error", err)
		}
	}

	return nil
}

// GetDirSize calculates the total size of a directory.
func GetDirSize(path string) (int64, error) {
	var size int64
	
	err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			size += info.Size()
		}
		return nil
	})
	
	return size, err
}

// GetFileType returns the ELF type of a file, or empty string for non-ELF files.
func GetFileType(path string) string {
	file, err := elf.Open(path)
	if err != nil {
		return ""
	}
	defer file.Close()
	
	switch file.Type {
	case elf.ET_EXEC:
		return "ET_EXEC"
	case elf.ET_DYN:
		return "ET_DYN" 
	case elf.ET_REL:
		return "ET_REL"
	default:
		return "ET_NONE"
	}
}

// IsEmptyDir checks if a directory is empty.
func IsEmptyDir(path string, dirEntry os.DirEntry) bool {
	if !dirEntry.IsDir() {
		return false
	}
	
	entries, err := os.ReadDir(path)
	if err != nil {
		return false
	}
	
	return len(entries) == 0
}

// IsStaticLibrary checks if a file is a static library (.a file or archive).
func IsStaticLibrary(path string) bool {
	// Check by extension first
	if strings.HasSuffix(path, ".a") {
		return true
	}
	
	// Check by archive magic number
	file, err := os.Open(path)
	if err != nil {
		return false
	}
	defer file.Close()
	
	magic := make([]byte, 8)
	n, err := file.Read(magic)
	if err != nil || n < 8 {
		return false
	}
	
	return string(magic) == "!<arch>\n"
}

// Filename extracts the filename from a path.
func Filename(path string) string {
	n := strings.LastIndex(path, "/")
	if n == -1 {
		return path
	}
	
	return path[n+1:]
}

	// Fall back to copying the file
	srcFile, err := os.Open(src) // #nosec G304 - src path is controlled by caller
	if err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_open_source_file"))
	}

	defer func() { _ = srcFile.Close() }()

	dstFile, err := os.Create(dst) // #nosec G304 - dst path is controlled by caller
	if err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_create_destination_file"))
	}

	defer func() { _ = dstFile.Close() }()

	// Use buffer from pool for better performance
	buffer := bufferPool.Get().([]byte)
	defer bufferPool.Put(&buffer)

	if _, err := io.CopyBuffer(dstFile, srcFile, buffer); err != nil {
		return errors.Wrap(err, i18n.T("errors.files.failed_to_copy_file_content"))
	}

	// Copy file permissions
	if srcInfo, err := srcFile.Stat(); err == nil {
		if err := os.Chmod(dst, srcInfo.Mode()); err != nil {
			logger.Warn(i18n.T("logger.tryhardlink.warn.failed_to_copy_file_1"), "dst", dst, "error", err)
		}
	}

	return nil
}
