package pacman

import (
	"strings"
	"testing"
)

func TestGetBaseInstallArgs(t *testing.T) {
	args := getBaseInstallArgs()
	expected := []string{"-S", "--noconfirm"}

	if len(args) != len(expected) {
		t.Errorf("getBaseInstallArgs() returned %d args, want %d", len(args), len(expected))
	}

	for i, arg := range expected {
		if i >= len(args) || args[i] != arg {
			t.Errorf("getBaseInstallArgs()[%d] = %q, want %q", i, args[i], arg)
		}
	}
}

func TestDotBuildinfoTemplate(t *testing.T) {
	if dotBuildinfo == "" {
		t.Error("dotBuildinfo template is empty")
	}

	requiredFields := []string{
		"format = 2",
		"pkgname = {{.PkgName}}",
		"pkgver = ",
		"buildtool = yap",
	}

	for _, field := range requiredFields {
		if !strings.Contains(dotBuildinfo, field) {
			t.Errorf("dotBuildinfo template missing field: %s", field)
		}
	}
}

func TestDotPkginfoTemplate(t *testing.T) {
	if dotPkginfo == "" {
		t.Error("dotPkginfo template is empty")
	}

	requiredFields := []string{
		"pkgname = {{.PkgName}}",
		"pkgver = ",
		"pkgdesc = {{.PkgDesc}}",
		"size = {{.InstalledSize}}",
		"arch = {{.ArchComputed}}",
	}

	for _, field := range requiredFields {
		if !strings.Contains(dotPkginfo, field) {
			t.Errorf("dotPkginfo template missing field: %s", field)
		}
	}

	if !strings.Contains(dotPkginfo, "Generated by yap") {
		t.Error("dotPkginfo should contain yap attribution")
	}
}

func TestDotMtreeTemplate(t *testing.T) {
	if dotMtree == "" {
		t.Error("dotMtree template is empty")
	}

	requiredElements := []string{
		"#mtree",
		"/set type=file uid=0 gid=0 mode=644",
		"{{- range . }}",
		"{{- if eq .Type \"dir\" }}",
		"{{- else if eq .Type \"symlink\" }}",
	}

	for _, element := range requiredElements {
		if !strings.Contains(dotMtree, element) {
			t.Errorf("dotMtree template missing element: %s", element)
		}
	}
}

func TestPostInstallTemplate(t *testing.T) {
	if postInstall == "" {
		t.Error("postInstall template is empty")
	}

	requiredHooks := []string{
		"pre_install()", "post_install()", "pre_upgrade()", "post_upgrade()",
		"pre_remove()", "post_remove()",
	}

	for _, hook := range requiredHooks {
		if !strings.Contains(postInstall, hook) {
			t.Errorf("postInstall template missing hook: %s", hook)
		}
	}
}

func TestSpecFileTemplate(t *testing.T) {
	if specFile == "" {
		t.Error("specFile template is empty")
	}

	requiredFields := []string{
		"pkgname={{.PkgName}}",
		"pkgver={{.PkgVer}}",
		"pkgrel={{.PkgRel}}",
		"pkgdesc=\"{{.PkgDesc}}\"",
		"package() {",
	}

	for _, field := range requiredFields {
		if !strings.Contains(specFile, field) {
			t.Errorf("specFile template missing field: %s", field)
		}
	}
}

func TestTemplateConsistency(t *testing.T) {
	templates := map[string]string{
		"dotBuildinfo": dotBuildinfo,
		"dotPkginfo":   dotPkginfo,
		"dotMtree":     dotMtree,
		"postInstall":  postInstall,
		"specFile":     specFile,
	}

	for name, template := range templates {
		if template == "" {
			t.Errorf("Template %s is empty", name)
		}
	}
}
